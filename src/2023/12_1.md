
### SRP的顶层结构

为了解决内置渲染管线（Built-In Render Pipeline）在应对日新月异的渲染需求时过于僵硬，不够灵活的问题，Unity推出了可编程渲染管线（Scriptable Render Pipeline）的概念，按照官方文档提供的解释，SRP在顶层设计上做了3个维度的区分，分别是：

1. 可编程渲染后端（Scriptable Render Backend），主要由Cpp语言编写的运行时基础框架，其本身不可编程，但是向可编程管线的实现层提供丰富且高效的API；
2. 核心公共件（Core RP），以C#和ShaderLab语言编写的一些列公共库为主，提供不依赖于具体渲染管线的基础服务；
3. 渲染管线实现层（Render Pipelines），是基于上两层实现的具体渲染管线解决方案，可供客制化，官方样板主要有URP和HDRP。

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/01.png?raw=true)

相比开源的“核心公共件”和“渲染管线实现层”来说“可编程渲染后端”作为运行在底层的黑盒，对我们影藏了大量的数据管理和图形渲染逻辑，如果说“渲染管线实现层”指挥了管线的具体调度节奏，那么“可编程渲染后端”就是调度后被安排来真正完成具体功能的那一位。在上图红框中可见，Unity官方将“后端”区分为：“context”，“culling”，“draw”和“batch renderer”等节点，对标了Native源码中四个重要的功能模块。我们不妨由此出发来深入了解SRP的运作机理。首先结合应用层调用方式和源码阅读，简单总结这些模块的功能如下：

1. Context -> 承载了一次完整的渲染管线提交所需数据，同时也提供了各种对外方法的入口；
2. Culling -> 负责判断场景内所有激活状态的Renderer的可见性，过滤出所有可见且合法的渲染对象；
3. Draw -> 底层绘制逻辑，负责分类整理和排序Renderer，收集和设置渲染参数，最终提交渲染线程执行绘制；
4. Batch Renderer -> Srp合批渲染器，通过判断相邻渲染对象之间的属性，筛选和组织对象进行合批处理。

