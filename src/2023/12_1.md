
### SRP的顶层结构

为了解决内置渲染管线（Built-In Render Pipeline）在应对日新月异的渲染需求时过于僵硬，不够灵活的问题，Unity推出了可编程渲染管线（Scriptable Render Pipeline）的概念，按照官方文档提供的解释，SRP在顶层设计上做了3个维度的区分，分别是：

1. 可编程渲染后端（Scriptable Render Backend），主要由Cpp语言编写的运行时基础框架，其本身不可编程，但是向可编程管线的实现层提供丰富且高效的API；
2. 核心公共件（Core RP），以C#和ShaderLab语言编写的一些列公共库为主，提供不依赖于具体渲染管线的基础服务；
3. 渲染管线实现层（Render Pipelines），是基于上两层实现的具体渲染管线解决方案，可供客制化，官方样板主要有URP和HDRP。

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/01.png?raw=true)

相比开源的“核心公共件”和“渲染管线实现层”来说“可编程渲染后端”作为运行在底层的黑盒，对我们影藏了大量的数据管理和图形渲染逻辑，如果说“渲染管线实现层”指挥了管线的具体调度节奏，那么“可编程渲染后端”就是调度后被安排来真正完成具体功能的那一位。在上图红框中可见，Unity官方将“后端”区分为：“context”，“culling”，“draw”和“batch renderer”等节点，对标了Native源码中四个重要的功能模块。我们不妨由此出发来深入了解SRP的运作机理。首先结合应用层调用方式和源码阅读，简单总结这些模块的功能如下：

1. Context -> 承载了一次完整的渲染管线提交所需数据，同时也提供了各种对外方法的入口；
2. Culling -> 负责判断场景内所有激活状态的Renderer的可见性，过滤出所有可见且合法的渲染对象；
3. Draw -> 底层绘制逻辑，负责分类整理和排序Renderer，收集和设置渲染参数，最终提交渲染线程执行绘制；
4. Batch Renderer -> Srp合批渲染器，通过判断相邻渲染对象之间的属性，筛选和组织对象进行合批处理。

在“渲染管线实现层”（比如URP）中也可以找到上述核心模块的“分身”。它们有的直接映射了本体，例如Native中的Context和URP中的Context对象，还有的则直接或间接触发了上述模块功能：

1. Context.Cull -> 直接对应了“后端”中的Culling，负责渲染对象的可见性判断，也负责生成RenderQueue队列（后续展开）；
2. Context.Execute ->（如URP中的ExecuteCommandBuffer）负责填充Context中的渲染指令队列（CommandQueue）；
3. Context.Submit -> 向“后端”Draw 模块一次性提交所有压入的渲染指令，在Draw的过程中还会进一步触发Batch Renderer，构造合批渲染。

下面分别简述下这3个重要功能点的内部执行逻辑：

### Cull

剔除部分的工作量多寡与场景复杂度正相关，且场景相机，灯光和阴影贴图数量的多寡还可对部分剔除工作产生倍增或倍减的效果。检查Profiler发现，在通常情况下耗时比较突出的剔除工作主要有：（1）**阴影剔除**（ShadowCulling）和（2）**动态场景渲染对象剔除**（SceneDynamicObjectsCulling）。其他可能参与剔除的类别还有：

3. 静态遮挡剔除（Static Occlusion Culling）
4. 地形剔除（Cull Terrains）
5. 探针剔除（ReflectionProbe Update）
6. 灯光剔除（Light Culling）

你能否也在Profiler中看到它们取决于你的Unity工程是否预计算并存储了潜在可见集合（Potentially Visible Set: PVS），或使用了Unity原生的地形和反射探针系统，亦或是设置了多光源（Spot和Point Light）。只是即便开启了上述额外的剔除项目，在一般情况下Culling阶段的主要负担还是在**阴影**和**场景动态物体**剔除上面，下面我们逐一解析下。


#### Shadow Culling

首先什么是阴影剔除？

我们知道平行光光源视角通常被设置为一个较大的矩形正交投影视锥体，可以覆盖整个场景。这样可以确保任何在光线路径上的物体都会生成相应的阴影，但只是确保有无投影，受阴影贴图分辨率影响，必须找到合适的投影范围才能生成高质量的投影。因此在实际计算阴影贴图时，Unity会考虑摄像机的视锥体的影响，利用远近裁剪面限定了限定平行光光源的矩形正交投影视锥体的尺寸，使矩形投影体永远聚焦在热点区域附近。之后为了进一步缩小计算范围，还需要根据摄像机视锥体的信息进行裁剪，Unity为此计算了摄像机视锥体的边界盒（Bounding Box），然后将该边界盒扩展一定距离，再与聚焦后的矩形正交投影视锥体做交集，形成最终的光源投影范围，此区域一般由6~10块平面合围而成。

而所谓的阴影剔除就是先于投影计算做准备，主要通过对6~10块平面做相交测试，将不在光源投影范围的物体从投影计算中剔除出去，此外如果开启了动态遮挡剔除，Unity也会利用内置的Umbra系统参与计算（此处暂略）。剔除过程由Jobs系统管理，也就是说是多线程并发处理的，参考如下Profiler截图：

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/02.png?raw=true)

图中红框标出的**Shadows.CullShadowCastersDirectional**专门剔除被平行光源影响的投影物体，Unity将场景内所有参与阴影投影的物体分成一定数量的组（Group），之后为每一个光源+投影物体组的组合创建一个专门的剔除工作任务，由Jobs分派到合适的线程上工作。结合工程实例的表现效果可知，阴影剔除总的工作负载受以下因素影响：

- 与场景中开启阴影的光源数量正相关。即便场景非常简单（比如只有1个投影物体），但有N个投影光源，Unity仍然会针对每个光源派发总共N个Jobs进行处理。
- 与场景中投射阴影的游戏对象数量正相关。如果对象数量很多，Unity会将它们划分到不同Group里，这样就会产生Group总数 x 投影光源总数个Jobs。

一个简单结论：当ShadowCull耗时过高时，最有效的方法就是减少投影物体和光源的数量。

#### Scene Dynamic Object Culling

动态场景渲染对象剔除的目的是提前过滤掉场景中摄像机不可见的渲染对象，为后续管线流程减负。注意此处的Dynamic并非指渲染对象本身的Static属性，而是在运行时实时计算物体可见性的方案，与需要大量**预计算**的静态遮挡剔除技术相区别。动态场景渲染对象剔除包括了**视锥剔除**和**动态物体遮挡剔除**两个方面，其中实时的动态物体遮挡剔除（Occlusion Culling）使用内建的第三方Umbra系统，该系统默认是关闭的，需要手动开启并配合轻度预计算（只涉及空间划分）。关于这些可见性判断的具体算法不是本文的主题，不过可以肯定的是，手机端TBDR管线可有效避免片元因前后遮挡引起的OverHead，且在各种合批技术的加持下，通过付出不很稳定的额外CPU资源去换取少量但稳定的渲染资源收集和提交消耗这件事是否值当还两说，需要具体到项目（场景）具体判断。

由于每一帧等待Cull的目标是全场景中激活的渲染对象，数量可观，如果从数据流的角度出发，Scene Dynamic Object Culling还是有许多说之处的。首先基于每一个场景Unity都维护了一个叫**SceneDynamicObjects**的队列，它装载了所有处于激活状态下的渲染对象引用 ，与此同时它们在队列中的下标又构成了另一个重要的数据队列**IndexList** 。我们知道整个Culling过程是由Jobs System负责规划和派发的，视负载不同前后可能有多组线程参与计算，每个线程实际负责IndexList上的一个区段，线程内遍历这段IndexList，对每个读取到的渲染对象应用可见性判断算法，这就构成了一组**Cull Job**，而多组这样的Jobs之后还会再追加一次**Combine Job**，从下面Porfiler截图中可以得到印证：

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/03.png?raw=true)

借用官方讲座的截图（下图），多组**Cull Job**运行在独立线程中（对应一种颜色），线程内部访问的**IndexList**数据段彼此独立，不产生竞太，当执行完可见性判断逻辑后，**Cull Job**丢弃没有通过的索引，余下索引回填到数组中，同时保证向队列前端对齐靠紧：

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/04_1.png?raw=true)


由于**Cull Job**的这种工作方式，必然导致它们的产出数组在**IndexList**内部是不连续的，Unity利用追加的**Combine Job**如下图所示这般重新规划整理List，过程就不再赘述了。

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/04_2.png?raw=true)


#### Execute RenderQueue

经过Combine之后获得的是可见渲染对象的索引队列，而这些渲染对象（Renderer）的实例在内存中的分布肯定是不连续的。我们知道Jobs系统为了提高并发运算效率，在派发多线程任务时会要求将所有待处理数据尽可能处理成连续排布的形式，于是便有了随后的**ExecuteRenderQueueJob**（该过程同样由多线程执行），目标是将各种引用类型的对象展平成值类型，同时对齐排列到一整片连续内存中，Unity从这里开始引入了2个新的概念：

- **RenderNode** -> 扁平化渲染对象（Renderer）后的值类型结构体，包含渲染所需的一切信息（MaterialData，LayeringData，LightMapST，LightMapIndex，RendererType，RendererPriority，CastShadow，ReceiveShadow，ProbeUsage，DynamicOcc，RenderingLayerMask，StaticBatchInfo，etc...）；
- **RenderNodeQueue** -> 由RenderNode组成的数据队列，用于保证数组元素在内存上是连续的。

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/05.png?raw=true)

所以**ExecuteRenderQueueJob**过程也很简单：遍历**IndexList**，找到并读取对应Renderer，然后将数据展开到RenderNode结构上，依序写入RenderNodeQueue。如下图所示，到目前为止队列中RenderNode的前后顺序由Cull后的**IndexList**排列属性决定，Culling过程会随机剔除部分对象，而Culling前的原始**IndexList**又由前文提及的维护了全场景渲染对象的**SceneDynamicObjects**队列决定，该队列内Renderer前后排列顺序则由各自的初始化时机决定，故可以认为，Unity并不在意RenderNode队列里各个Node在逻辑上的乱序状态。

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/06.png?raw=true)

**RenderNodeQueue**是Cull部分的终点，也是实际渲染的起点，事实上如果把渲染一帧画面比作烹饪一桌菜肴，那么整个Culling过程就好似饭店后厨在制备酒席前的**备料**阶段，场景内的食材（原始渲染对象）经过洗净去皮（Cull掉不需要不可见部分）以及切段分盘盛放（格式化和扁平化数据结构），最终一排排整齐罗列在工作台上（**RenderNodeQueue**）。

### Execute 

Context.**Execute**相对简单，它只负责以Command的形式收集来自应用层的渲染指令，处理类似任务的前端接口还有：

- CommandBuffer.Blit
- CommandBuffer.DrawMesh
- ScriptableRenderContext.DrawRenderers
- ScriptableRenderContext.DrawShadows

虽然接口名给人一种即时执行的暗示，但它们本质都是向SRP底层提供的指令队列中填充不同内容的Command指令。

Unity共有三种不同类型的Command，它们分别是：

1. ShadowDrawingSettings：对应DrawShadowCommands队列
2. DrawRenderersCommand：对应DrawRenderersCommands队列
3. RenderingCommandBuffer：对应CommandBuffers队列

此外Unity底层还单独维护了一个的用于记录全局先后顺序的队列，叫做**Commands**，类型是：dynamic_array\<Command\> ，每当用户向指令队列添加新的Command时，这个队列也会添加一份该Command的引用，具体流程参考下图：

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/07.png?raw=true)

在**Submit**前，几乎所有的绘制或渲染接口都是调用向上述队列中添加指令对象，指令内容由Command对象记录，指令顺序被**Commands**队列保持。继续套用烹饪酒席的例子做类比的话，**Execute**阶段是酒店**收集**客户菜单的过程，菜单中的每道菜对应了一个独立的Command指令，决定了所需备料的种类和烹饪方法；而菜单中菜品的先后顺序也被固定了下来，以确保冷盘（前菜），正餐和甜点的上菜顺序不会错乱。

### Submit

**Submit**的作用是向SRP底层一次性提交Context中的所有渲染指令，驱动真正的“绘制”和“渲染”逻辑。该过程的CPU消耗对应了主线程Profiler中的ScriptableRenderContext.**Submit**条目，我们可以在Scriptable Render Loop下找到它。**Submit**之后，后厨就收到了客户的订单（**Commands**队列），于是便开始依序遍历订单中每一个菜品（Command），在主线程内逐个处理它们。

我们知道不同的“菜肴”会对食材的种类和炒制的方法有不同的要求，渲染指令同样会对渲染对象和渲染管线有不同的过滤条件和配置要求，以常见的“菜品”DrawRenderersCommand为例（就是负责DrawOpaque或者DrawTransparent的那个），它需要将执行分解为2个阶段进行：

1. 数据准备阶段（PrepareDrawRenderers）
2. 数据执行阶段（ExecuteDrawRenderers）

#### 数据准备阶段

**数据准备阶段**（PrepareDrawRenderers）的CPU消耗对应了Profiler中的RenderLoop.**Prepare**（准备阶段）和RenderLoop.**Sort**（排序阶段）两个条目：

1. RenderLoop.**Prepare** -> 基于渲染指令自身的属性和影响范围，挑选出参与该指令的细粒度渲染对象。类比烹饪菜肴的话，可以看做是从全部备料中选出当前菜品所需的部分，同时加工备料，使成为适合下锅烹饪的形态。
2. RenderLoop.**Sort** -> 对挑选出的细粒度渲染对象进行排序，以确定它们进入合批通道的先后顺序。做类比的话，相当于确定各项处理后食材的下锅顺序。

RenderLoop.**Prepare**到底做了什么还是有必要深究一下的。我们知道经过Culling过程后全场景可见的Renderer信息被展平在了名为RenderNode的内存上，可以笼统的让RenderNode对象与游戏场景中每一个可见的Renderer对应上，但是光到Renderer这一层还不是最细粒度的渲染对象，精确包含全部渲染要素的最小集合是ShaderPass，所以Unity需要在数据准备阶段（Prepare）进一步细化和过滤，具体参考下图：

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/08.png?raw=true)

（1个）RenderNode -> （1个或多个）Material -> （1个或多个）Pass

在RenderLoop.**Prepare**阶段，所有被梳理出来包含了单个ShaderPass全部数据的对象叫做**ScriptableLoopObjectData**，后文简称“ObjectData”。紧接着Unity会基于ObjectData的属性和当前DrawRendererCommand的具体过滤需求进行二次过滤，简介筛选条件如下：

1. LayerMask
2. RenderingLayerMask     -> 对应不同(Universal)Renderer（和RendererAsset设置）
3. MotionVectorPassRequested
4. ShaderTagID -> 对应“Lit”，“SimpleLit”和“UnLit”等内置或用户手动设置的TagID

至于RenderLoop.**Sort**阶段，自然是负责将ObjectData对象按规则排序，底层逻辑中**ScriptableLoopObjectData**是一个相对轻量化的结构体（struct），属于值类型，具体定义如下：

```cpp
struct ScriptableLoopObjectData
{
    RenderObjectData            data;                //记录有参与比较的各种变量
    const SharedMaterialData*   sharedMaterial;      //指针 -> 指向材质类
    const ShaderLab::Pass*      pass;                //指针 -> 指向Pass
    UInt32                      passIndex;           //值类型索引
    UInt32                      passOrder;           //值类型优先级
};
```

复杂且与Sorting无关的数据会被Unity直接存放到指针中，而需要在排序比较中反复使用的参数则全部被整合成了值类型的数据结构（参考RenderObjectData）。

影响排序的主要因素如下：

```cpp
SortSortingLayer	// global sorting layer（全局级）
SortRenderQueue		// material render queue（材质级）
SortBackToFront		// 基于从后往前的规则
SortQuantizedFrontToBack // 基于从前往后（量化）的规则 -> 有利于TBDR优化Overhead
SortOptimizeStateChanges // 优化排序以提高效率，综合考虑了: static batching,  lightmaps, material sort key, geometry ID
SortCanvasOrder          // Canvas系统内，在距离相同前提下的 sort priority 
SortRendererPriority	 // renderer priority (当render queue不可区分时使用)
```

比如，一个不透明物体的规则通常由以下几种排序条件组成：

```cpp
SortCommonOpaque = SortSortingLayer | 
        SortRenderQueue | 
        SortQuantizedFrontToBack | 
        SortOptimizeStateChanges | 
        SortCanvasOrder
```

比较的顺序如下，可以理解为一旦某个比较节点得出结果（非相同）则立即返回结果：

SortSortingLayer(全局SortingLayer) -> 
SortRenderQueue(材质上的RenderQueue) -> 
SortRendererPriority(SRP专用，作为RenderQueue相等前提下的备用) -> 
SortBackToFront(依相机连续距离从后向前排序，半透明物体使用)  -> 
SortQuantizedFrontToBack(依相机离散距离从前向后排序，不透明物体使用) ->  
SortOptimizeStateChanges(SRP Batcher兼容性排序优化，让能一起Batch的排序到一起) ->  
SortCanvasOrder(画布顺序) ->  
NodeIndex Or PassOrder 

基于以上分析可以，像**Prepare**和**Sort**这类逻辑简单，可独立拆分，同时又面对海量同类数据的工作非常适合多线程并发执行，事实上也是如此，Unity在多组Worker上执行**Prepare**操作，其产出（一段ObjectData队列）则被后起的多条**Sort**线程消费，参考下图：

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/09.png?raw=true)

**Sort**这类计算密集型的工作非常适合多线程（多核）执行，上图中Unity将**Sort**任务拆分成了87个实例共运行在11个线程中，累积总耗时达到1.44ms，实际耗时在多线程优化下仅有总耗时的不到一成。换言之，对于核心数量偏少偏弱的（中低端）移动平台来说，控制渲染对象的总量（即便有合批加持）仍然很有必要。

#### 数据执行阶段

准备好数据后我们正式进入**数据执行阶段**（ExecuteDrawRenderers），它在SRP语境中对应了Profiler中RenderLoop.**DrawSRPBatcher**条目。 由于SRPBatcher的出色性能，工程默认开启了该项优化，对应下图箭头处：

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/10.png?raw=true)

