
### SRP的顶层结构

为了解决内置渲染管线（Built-In Render Pipeline）在应对日新月异的渲染需求时过于僵硬，不够灵活的问题，Unity推出了可编程渲染管线（Scriptable Render Pipeline）的概念，按照官方文档提供的解释，SRP在顶层设计上做了3个维度的区分，分别是：

1. 可编程渲染后端（Scriptable Render Backend），主要由Cpp语言编写的运行时基础框架，其本身不可编程，但是向可编程管线的实现层提供丰富且高效的API；
2. 核心公共件（Core RP），以C#和ShaderLab语言编写的一些列公共库为主，提供不依赖于具体渲染管线的基础服务；
3. 渲染管线实现层（Render Pipelines），是基于上两层实现的具体渲染管线解决方案，可供客制化，官方样板主要有URP和HDRP。

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/01.png?raw=true)

相比开源的“核心公共件”和“渲染管线实现层”来说“可编程渲染后端”作为运行在底层的黑盒，对我们影藏了大量的数据管理和图形渲染逻辑，如果说“渲染管线实现层”指挥了管线的具体调度节奏，那么“可编程渲染后端”就是调度后被安排来真正完成具体功能的那一位。在上图红框中可见，Unity官方将“后端”区分为：“context”，“culling”，“draw”和“batch renderer”等节点，对标了Native源码中四个重要的功能模块。我们不妨由此出发来深入了解SRP的运作机理。首先结合应用层调用方式和源码阅读，简单总结这些模块的功能如下：

1. Context -> 承载了一次完整的渲染管线提交所需数据，同时也提供了各种对外方法的入口；
2. Culling -> 负责判断场景内所有激活状态的Renderer的可见性，过滤出所有可见且合法的渲染对象；
3. Draw -> 底层绘制逻辑，负责分类整理和排序Renderer，收集和设置渲染参数，最终提交渲染线程执行绘制；
4. Batch Renderer -> Srp合批渲染器，通过判断相邻渲染对象之间的属性，筛选和组织对象进行合批处理。

在“渲染管线实现层”（比如URP）中也可以找到上述核心模块的“分身”。它们有的直接映射了本体，例如Native中的Context和URP中的Context对象，还有的则直接或间接触发了上述模块功能：

1. Context.Cull -> 直接对应了“后端”中的Culling，负责渲染对象的可见性判断，也负责生成RenderQueue队列（后续展开）；
2. Context.Execute ->（如URP中的ExecuteCommandBuffer）负责填充Context中的渲染指令队列（CommandQueue）；
3. Context.Submit -> 向“后端”Draw 模块一次性提交所有压入的渲染指令，在Draw的过程中还会进一步触发Batch Renderer，构造合批渲染。

下面分别简述下这3个重要功能点的内部执行逻辑：

### Cull

剔除部分的工作量多寡与场景复杂度正相关，且场景相机，灯光和阴影贴图数量的多寡还可对部分剔除工作产生倍增或倍减的效果。检查Profiler发现，在通常情况下耗时比较突出的剔除工作主要有：（1）**阴影剔除**（ShadowCulling）和（2）**动态场景渲染对象剔除**（SceneDynamicObjectsCulling）。其他可能参与剔除的类别还有：

3. 静态遮挡剔除（Static Occlusion Culling）
4. 地形剔除（Cull Terrains）
5. 探针剔除（ReflectionProbe Update）
6. 灯光剔除（Light Culling）

你能否也在Profiler中看到它们取决于你的Unity工程是否预计算并存储了潜在可见集合（Potentially Visible Set: PVS），或使用了Unity原生的地形和反射探针系统，亦或是设置了多光源（Spot和Point Light）。只是即便开启了上述额外的剔除项目，在一般情况下Culling阶段的主要负担还是在**阴影**和**场景动态物体**剔除上面，下面我们逐一解析下。


#### Shadow Culling

首先什么是阴影剔除？

我们知道平行光光源视角通常被设置为一个较大的矩形正交投影视锥体，可以覆盖整个场景。这样可以确保任何在光线路径上的物体都会生成相应的阴影，但只是确保有无投影，受阴影贴图分辨率影响，必须找到合适的投影范围才能生成高质量的投影。因此在实际计算阴影贴图时，Unity会考虑摄像机的视锥体的影响，利用远近裁剪面限定了限定平行光光源的矩形正交投影视锥体的尺寸，使矩形投影体永远聚焦在热点区域附近。之后为了进一步缩小计算范围，还需要根据摄像机视锥体的信息进行裁剪，Unity为此计算了摄像机视锥体的边界盒（Bounding Box），然后将该边界盒扩展一定距离，再与聚焦后的矩形正交投影视锥体做交集，形成最终的光源投影范围，此区域一般由6~10块平面合围而成。

而所谓的阴影剔除就是先于投影计算做准备，主要通过对6~10块平面做相交测试，将不在光源投影范围的物体从投影计算中剔除出去，此外如果开启了动态遮挡剔除，Unity也会利用内置的Umbra系统参与计算（此处暂略）。剔除过程由Jobs系统管理，也就是说是多线程并发处理的，参考如下Profiler截图：

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_1/02.png?raw=true)

图中红框标出的**Shadows.CullShadowCastersDirectional**专门剔除被平行光源影响的投影物体，Unity将场景内所有参与阴影投影的物体分成一定数量的组（Group），之后为每一个光源+投影物体组的组合创建一个专门的剔除工作任务，由Jobs分派到合适的线程上工作。结合工程实例的表现效果可知，阴影剔除总的工作负载受以下因素影响：

- 与场景中开启阴影的光源数量正相关。举个极端例子，在简单场景中（产生阴影的对象很少，比如只有1个），但是有N个能够产生阴影的光源，那么在线程池资源充足的情况下就会产生N个Jobs并行处理。
- 与场景中投射阴影的游戏对象数量正相关。这点主要影响Group的数量，越复杂的场景，投影对象越多，Unity就会分出更多的Group，再乘上投影光源的数目，从而产生更多的Jobs负载。

> 一个简单结论：当ShadowCull耗时过高时，最有效的方法就是减少投影物体和光源的数量。

#### Scene Dynamic Object Culling








