
### \[Unity\]Mesh和Texture资源加载和优化知识点x3

### 1 资源是如何上传到GPU的

比起干说，还是结合Unity Profiler做实验来得直观和有说服力。

首先准备一个带Mesh的Prefab，保证从磁盘加载到CPU内存之前游戏场景中没有其他实例在使用该Prefab所指向的Mesh资源，然后在运行过程的某个时刻开始，先后调用Load和Unload逻辑，通过Unity的Profiler观察GPU内存总量变化和上传数据变化。

```c#
public class TestUpload : MonoBehaviour
{
	private List<GameObject> tps = new List<GameObject>();

	void Start()
	{
	    StartCoroutine(CountDown());
	}

	IEnumerator CountDown()
	{
	    yield return new WaitForSeconds(0.2f);
	    JustLoad("Assets/test.prefab");
	    yield return new WaitForSeconds(0.2f);
	    ReleaseAsset(0);
	}


	private void JustLoad(string path)
	{
	    var go = AssetDatabase.LoadAssetAtPath<GameObject>(path); //只加载，甚至不激活和显示
	    tps.Add(go);
	}

	private void ReleaseAsset(int idx)
	{
	    tps[idx] = null;
	    EditorUtility.UnloadUnusedAssetsImmediate(); //使用此接口及时触发GPU端资源释放
	}

	private void OnDestroy()
    {
        tps.Clear();
    }
}


```

下图来自Profiler：

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_2/01.png?raw=true)

在Unity运行期间，加载资源（Mesh或Texture）完成的同时，无论当前帧是否有渲染目标Mesh或者使用目标Texture的需要（即便只是加载了资源，之后什么都不操作）都会触发向GPU上传数据的操作，并被保存在名叫GfxBuffer的内部类中。传输模式在Editor模式下是同步的，会在触发上传的同一帧内完成向GPU提交全部数据(Header和Binary)。 同样，当Unity不再持有该Mesh资源的引用，并且在寻求主动释放GPU资源时，显存中的关联资源（Vertex/Index Buffer等）才会被释放，在Editor模式下，这个操作对应了`EditorUtility.UnloadUnusedAssetsImmediate()`方法。

为了知道Unity在上传GPU资源数据时到底干了什么，这边比较了一下上传关键帧和其他时间CPU部分负载的异同，利用Profiler自带Hierarchy查找关键词Mesh，比较异同后发现：处于上传负载的关键帧时期，Unity触发了2个独特的函数调用： 

1. Mesh.**AwakeFromLoad**
2. Mesh.**CreateMesh**

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_2/02.png?raw=true)

这两个方法在Prolier中的具体执行层级如下图所示：

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_2/03.png?raw=true)

可见当读取磁盘数据的回调一旦完成，就触发了`Mesh.AwakeFromLoad`，进而触发了`Mesh.CreateMesh`，而这个方法内部主要负责将Mesh中的"Vertice"和"Index"数据依序通过`GeometryBuffer`上传到GPU端。

进一步梳理下Mesh和Texture等资源的处理流程，可以区分为两种方式：

1. 与场景同时加载
	- 其本质也是从磁盘加载，但是随同场景出现而出现
	- 在调用Profiler测试时，往往因为场景早于Profiler工作而出现，所以一部分基于场景的Mesh和Texture早已在GPU了
2. 运行时由代码触发的从磁盘加载
	- 这里如果是从构建好的AssetBundle中获取数据，那么就有2中不同的上传模式：
		1. Sync：
			- 该模式在资源build时期（就是打AssetBundle时期）会将数据的Header和Binary全部打包到`.res`文件内，
			- 在游戏运行时，Unity从磁盘（Bundle）中读取这个文件到内存，之后会由主线程于一帧内将资源（Header和Binary）Upload到GPU。
		2. Async
			- 还是在资源build时期，会将Header写入`.res`文件中，Binary数据则写入`.resS`文件中
			- 在游戏运行时，Unity从磁盘（Bundle）中读取`.res`文件到内存，解析出Header数据，之后Unity采用streams的方式从`.resS`文件中加载Binary数据到GPU，这个过程使用了一个固定大小的Ring Buffer（环形缓冲），而且还会利用多线程，分多帧处理。
	- 如果是从Resources目录读取资源，或者在Editor模式下调用AssetDatabase获取资源，那么统一走Sync模式

**备注1** Unity重复使用一段环形缓冲作为流式（Streaming）上传数据到GPU的区域，这么做的主要目的是避免重复开辟新的内存。在ProjectSettings->Quality->AsyncAssetUpload->BufferSize可以控制环形缓冲的大小，默认是4MB，最小可调到2MB，最大则是2GB。当单个Mesh或Texture的尺寸超过环形缓冲大小时，Unity不得不重新开辟RingBuffer以适应上传数据大小，出现这种情况会导致效率下降，因此最佳策略是手动调整BufferSize，以满足场景内最大Mesh/Texture的尺寸。

**备注2** Unity也提供了控制每帧Upload时间（ms）的接口和设置，可以在ProjectSettings->Quality->AsyncAssetUpload->TimeSlice中调节每一帧最大可占用的CPU时长，这个数值越大，意味着GPU将越快获得Mesh/Texture数据，代价是CPU在提交数据的这段时间内负荷增大。

![](https://github.com/bbccyy/NoteBook/blob/master/src/2023/12_2/04.png?raw=true)

注意只有在出发C#加载Mesh资源的那一帧（上传关键帧），系统才向GPU上传了一定数量是顶点和索引缓冲数据。那一帧过后，系统恢复“常态”。

部分关键参数名的含义参考如下官方文档：

Vertex Buffer Upload In Frame Count/Bytes|The amount of geometry that the CPU uploaded to the GPU in the frame. This represents the vertex/normal/texcoord data. There might already be some geometry on the GPU. This statistic only includes geometry that Unity transfers in a frame.
:---:|:---:
Index Buffer Upload In Frame Count/Bytes|The amount of geometry that the CPU uploaded to the GPU in the frame. This represents the triangle indices data. There might already be some geometry on the GPU. This statistic only includes geometry that Unity transfers in a frame.


### 2 allowSceneActivation

这个值的作用参考文档即可：[AsyncOperation.allowSceneActivation](https://docs.unity3d.com/ScriptReference/AsyncOperation-allowSceneActivation.html)

简单来说，我们可以通过在加载场景前将该变量设置为false，从而控制Unity专心于该场景的异步加载，直到完成度达到90%后(也可以提前，但是不能延后)再通过将allowSceneActivation设置为true从而重启其他处于队列中等待的AsyncOperation，比如Unity官方提到的`SceneManager.UnloadSceneAsync`。

我想说的是，有时候如果没有及时提前触发**非场景类**的AssetBundle异步加载，那么allowSceneActivation也会将这些Bundle的加载停住（stalled），由于是异步提交的，因此误停其他Bundle加载也很可能是偶发的，不一定在测试的时候必现，需要注意和提前规避。

### 3 ResetPreMappedBufferMemory


遇到一个战斗中内存突然暴增的问题，最终定位到时同屏粒子特效过多，触发了底层申请了较大缓存导致。而且通过控制允许一帧之内允许新显示的特效（加载，实例化，但是失活）数了，验证了内存开销可同屏显示的特效量成正相关。这个缓存可以通过ParticleSystem.ResetPreMappedBufferMemory重置

这个在小内存的机器上也会申请这么大的缓存吗？还是说只针对大内存机器会这样？如果这个缓存值是根据可用内存来的，那其实也还好，如果不是，那就得手动重置

当然对于这种问题，最好的方式是：控制同屏显示的特效时，既优化了体验，又优化了性能


### Ref

[Manual/ProfilerRendering](https://docs.unity3d.com/Manual/ProfilerRendering.html)